Лекция 1.1

Декомпозиция - метод, разбиение задачи на подзадачи 

Инкапсуляция - механизм, связывающий код и данные, защищающий от произвольного доступа

Наследование - механизм, с помощью которого один объект (произвольного класса) приобретает свойства другого объекта (родительского, базового класса)

Полиморфизм - механизм, позволяющий использовать один и тот же интерфейс для общего класса действий (операции +,-,*,/,++,--,[]...)
Статический - на этапе компиляции, перегрузка функций
Динамический - во время выполнения программы, с помощью виртуальных функций
Параметрический - на этапе компиляции, с использованием механизма шаблонов
_________________________________________________________________________________________________________________________________________________________________________________________________________________


Лекция 1.2


Классы
Имя - с заглавной буквы
private - закрытые члены (доступны только внутри класса)
public - открытые
protected - защищенные
наследование по умолчанию у class - private
наследование по умолчанию у struct - public


Действия над объектами классов:
1. Присваивание (почленное копирование)
2. Получить адрес объекта (&)
3. Передать объект в функцию
4. Вернуть объект в функции
5. Доступ к элементам объекта (. к объекту или -> при использовании указателя на объект)
6. Вызывать методы класса


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Пример:

int get_a() const {return a;)
Здесь const не меняет состояние объекта (набор полей данных)
Константные методы можно применять к константным и неконстантным объектам (расширение области применения)
А неконстантные методы можно применять только к неконстантным объектам
const в прототип!

class A {
	int a;
public:
	void set_a(int n);
	int get_a() const {return a;}
};

void A::set_a(int n) { // можно вынести тело функции из класса
	a = n;
}

Метод set_a задан прототипом
Метод get_a задан полностью - компилятор рассматривает как inline функцию (компилятор преобразует inline функцию в макрос)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


Абстрактный тип данных (АТД) - полностью скрыта структура, а работа производится через функции (нет открытых членов данных - public). Класс А из приера - АТД.


Оператор (statement) - действие, задаваемое конструкцией языка
Операция (operator) - операции языка (+,-,*,/), используются в выражениях


Ввели логический тип bool - true/false 
Нет типов по умолчанию
iostream = in + out
Объекты cin, cout, cerr (вывод в поток ошибок)


Работа с динамесеской памятью:
Операция new выделяет динамическую память и возвращает указатель на начало
int *p, *m;
p = new int; // в случае исключения ничего не узнаем
p = new(nothrow) int; // в случае ошибки вернет NULL  !!!!!!!!
p = new int (1); // инициализация
delete p;

m = new int[10]; //10 элементов
// инициализировать значение элементов массива в динамической памяти нельзя !!!!!!!
delete [] m;


Значения по умолчанию:
void f(int a, int b = 0, int c = 1);
Обращения:
f(3)		// a = 3, b = 0, c = 1;
f(3, 4)	// a = 3, b = 4, c = 1;
f(3, 4, 5)	// a = 3, b = 4, c = 5;


Пространства имен:
#include <iostream>
using namespace std;
//using - оператор
//std::cout, std::endl;

namespace std {
	// объявления, определения
}

namespace NS {
	char name[10];
	namespace SP {
		int var = 3;
	}
}

Можем расширить пространство имен		!!!!!!!!!!
Например добавить методы в std, создав новое пространство имен с тем же названием (std)

#include <iostream>
namespace std {
    int m = 777;
};

using namespace std;

int main() {
    cout << m << ' ' << 55 << endl;
    return 0;
}
_________________________________________________________________________________________________________________________________________________________________________________________________________________

Лекция 2.1
Ссылочный тип  данных 
Можно только инициализировать
a и b указывают на одну и ту же память
int a = 5;
int & b = a;
b += 5; // a = b = 10

Передача параметров в функию по значению (как обычно) или по ссылки

По значению - в функции создаем локальный временный объект, инииициализируется значением фактического параметра, при выходе уничтожается. Не можем менять значение самого фактического параметра

По ссылке - можем можем менять фактические параметры и возвращать ссылки (т.е. L-value)
L-value выражения стоят слева операции присваивания
R-value - справа

void swap(int & x, int & y) {
	int tmp = x;
	x = y;
	y = tmp;
}

int a = 5, b = 6;
swap(a, b);


Специальные методы класса
Конструктор - создание полей, инициализация
Конструктор копирования - при инициализации нового объекта при имении старого
Конструктор преобразований
Деструктор

a = A(7); //вызывает конструктор копирования, если A(const A & y), то работает. Нужен const!!! 

_________________________________________________________________________________________________________________________________________________________________________________________________________________

Лекция 2.2

Дружественные функции
friend void f(...);
friend void Y::f(...);
friend class Y
Нет наследования и транзитивности
class X {... operator int(); ...} - X можно привести к int

Префиксная и постфиксная ++
complex & operator ++ () {
	re = re + 1;
	im = im + 1;
	return *this;
}

complex & operator ++ (int) {
	complex c = *this;
	re = re + 1;
	im = im + 1;
	return c;
}


Перегрузка функций
Из одной области видимости (глобальная, пространство имен, класс)

Правила выбора перегруженной функции:
а) Точное отождествление -полное совпадение

б) Отождествление при помощи расширений - безопасное преобразование
Целочисленные расширения: char, short (signed / unsigned), enum, bool -> int (signed / unsigned)
Вещественные расширения: float -> double

в) Отождествление с помощью стандартных преобразований
1. Все числовые преобразования
2. Преобразования объекта произвольного класса к объекту однозначно доступного базового класса
3. Преобразование указателей:
	0 -> любой указатель
	любой указатель -> void*
 
г) Отождествление с помощью преобразований, определенных пользователем - конструктор или функция

void f(int)		передача по значению
void f(int &)	передача по ссылке
Работет только с f(1) - с константой, так как константу нельзя передать по обычной ссылке


_________________________________________________________________________________________________________________________________________________________________________________________________________________


Лекция 3.1

Наследование
Конструкторы, деструкторы и operator= не наследуются
Для классов наследование по умолчанию - private
Для структур наследование по умолчанию - public
Конструктор - сначала базового, потом свой
Деструктор - сначала свой, потом базового
Private основного присоедниняется к новому, но его поля не доступны
class A : public B {...};

public наследование
private_par + private_new
protected_par + pretected_new
public_pat + public_new

public наследование
private_new + private_par
protected_new + protected_par
public_new + public_par

protected наследование
private_new + private_par
protected_new + protected_par + public_par
public_new

private наследование
private_new + private_par + protected_par + public_par
protected_new
public_new

Если в базовом классе и производном есть поля с одинаковыми именами, то поля производного класса скрывают видимость, но не закрывают доступ

Области видимости при однинаковых именах
Глобальная - ::x
Пространство имен, класс N - N::x
Базовый класс ничего не знает про производные, так что из него нельзя иметь доступ к полям производного класса

namespace N
class A {}
class B:A {}
N::B obj;
obj.x = 10
obj.A::x = 20 (можно добраться до скрытого поля базового класса)


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
class A {...}
class B : public A {public: B(); B (const B &); ... } - есть явно описанный конструктор копирования
class С: public A {public: ... } - нет явно описанного конструктора копирования

B b1;		// A(), B()					два конструктора
B b2 = b1;	// A(), B(const B &)			конструктор и конструктор копирования (создание нового объекта класса A, дополнение копированием полей из объекта класса B)
C c1;		// A(), C()					два конструктора	
C c2 = c1;	// A(const A &), C(const C &)		два конструктора копирования (копирование части A, затем части C)


Если сами пишем конструктор для производного класса, то должны указывать списко инициализации для вызова конструктора базового класса

Приведение указателей
A a(...), *pa = &a;
B b(...), *pb = &b;
pa = pb; // нет ошибки, но закроются поля класса В
pa->print(); сработает из А класса
Но можно это обойти с помощью виртуальных функций
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Виртуальные функции (virtual)
1. Пишем в базовом классе: virtual void print() const;
2. И указывем, что выполнять с разными входными данными - объектами классов
3. В производном классе указывем метод с точно таким же прототипом: [virtual] void print() const;

И поэтому
A a(...), *pa = &a;
B b(...), *pb = &b;
pa = pb;
pa->print(); // Сработает метод из B класа (он найдется по типу класса указателя и методу virtual)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Если делаем в классе виртуальные методы, то делаем и виртуальные деструкторы!!!

Если в базовом классе virtual ~A(); (виртуальный деструктор)
А в базовом классе [virtual] ~B(); (тоже виртуальный деструктор)
	    или 	   virtual ~B();
	    или                ~B(); 

Лекция 3.2
Трансляторы, интерпретаторы, компиляторы
			
_________________________________________________________________________________________________________________________________________________________________________________________________________________

Лекция 4.1
Полиморфный класс - имеет виртуальную функцию
Для каждого полиморфного класса создается таблица указателей на его виртуальные методы - vtbl - массив, индекс элемента которого соответствует прототипу виртуальной функции класса, а содержимое - ее адресу.
В public неявно помещается указатель на табоицу - vtbl * pvtbl;

1. Таблица наследуется от базового класса
2. Происходит замещение адресов тех функций, прототипы которых совпали
3. Происходит добавление новых функций в конец таблицы

Если метод невиртуальный и вызывается из своего класса, то вызывется свой метод!!!

Прыгать по виртуальным функциям можно только если полностью совпадают прототипы!!!

Вызвать можно только то, что есть в базовом классе!!!

Априорные значения могут браться из базового класса!!!



Множественное наследование
class L {public: int n; ...};
class A: virtual public L {...};
class B: virtual public L {...};
class C: public A, public B {... void f(); ...};
Тогда получим
 L
/ \
A B
\ /
 C



static - хотим иметь глобальное поле для всех объектов класса. Каждый имеет к нему доступ, может менять.
Статические методы не могут пользоваться this, нестатическими членами класса, не могут быть виртуальными и константными (а inline могут).
К такому полю можно обратиться, не имея ни одного экземпляра класса - A::x = 1;

class A {
public:
	static int x;
	static void f (char c);
};
A::x;
A::f('a'):


_________________________________________________________________________________________________________________________________________________________________________________________________________________

Лекция 5.1

Средства обработки ошибки
Исключения try, catch, throw
Если в участке кода может возникнуть ошибка - заключаем в try-catch блок
Приведения типов для catch нет
catch обработчики баовых классов также ловят исключения производных классов
Поэтому сначала указываем catch обработчик производного класса, а потом базового
catch(...) - ловит все ошибки

Если поймали исключение:
1. Свертка стека
2. Срабатывание декструкторов
3. Освобождение памяти

Если поймали исключение, поднимаемся вверх, все за собой подчищая, доходим до catch



class A {
public:
	A () {cout << "Constructor of A\n";}
	~A () {cout << "Destructor of A\n";}
};
class Error {};
class Error_of_A : public Error {};
void f () {
	A a;
	throw 1;
	cout << "This message is never printed" << endl;
}
int main () {
	try {
		f ();
		throw Error_of_A();
	}
	catch (int) { cerr << "Catch of int\n"; }
	catch (Error_of_A) { cerr << "Catch of Error_of_A\n"; }
	catch (Error) { cerr << "Catch of Error\n"; }
	return 0;
}

вывод:
Constructor of A
Destructor of A
Catch of int


А если базовый класс - математические ошибки, которых много, то можно сделать так:
class MathEr {virtual void ErrProcess();};
class Overflow : public MathEr {void ErrProcess();};
class ZeroDivide : public MathEr {void ErrProcess();};

try { ...
}
catch (MathEr & m) {m. ErrProcess();}


Исключения, генерируемые в функциях
тип_рез имя_функции (список_арг) [const] throw (список_типов) { ... }
Вместо throw () можно написать noexcept
Если сгенерировалось недекларированное исключение, то вызывается unexpected()
Это единственный способ отслеживать работу конструкторов и деструкторов
В деструкторе не должно быть исключений!!!

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Процесс:
1. Генерация исключения
	throw x - конструктор копирования
	throw X(1) - конструктор
2. Перед выходом из try блока все остальные объекты удаляются, вызываются деструкторы, память освобождается.
3. Поиск нужного catch обработчика
	а) Нашли -> выполнение инструкций catch обработчика и продолжение работы программы с оператора, расположенным за последним обработчиком try блока
	б) Иначе продолжаем поиск, поднимаясь выше, продолжая свертку стека
	в) Если так и не нашли, то вызывается terminate()
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


Механизм RTTI
Стандартные исключения, которые генерирует сам компилятор (во время выполнения программы)
Нужно подключить
#unclude <typeinfo> // !!!!!!!!!!!!!!!!!!!!!!!! (кроме dynamic_cast)
1. dynamic_cast
2. typeid
3. type_info

1. dynamic_cast (также есть reinterpret_cast, static_cast, const_cast)
Для приведения ссылок или указателей ПОЛИМОРФНЫХ классов
dynamic_cast <целевой тип> (выражение)
Приводит производный класс к базовому всегда без ошибок
При ошибке возвращает - 0, если использовались указатели
				bad_cast (тип - стандартный класс), если использовались ссылки


Base * bp, b_ob;
Derived * dp, d_ob;
bp = & d_ob;
dp = dynamic_cast <Derived *> (bp); // приводим к типу Derived *
if (dp)
	cout << "Приведение типов прошло успешно"; 
bp = &b_ob;
dp = dynamic_cast <Derived *> (bp);
if (!dp)
	cout << "Приведения типов не произошло";


2. typeid
Определяет тип выражения во время выполнения программы
Применима ко всем: выражениям, типам данным, объектам классам
Возвращает ссылку на объект класса type_info
typeid(выражение)
typeid(имя_типа)

В классе type_info определены следующие открытые члены:
bool operator == (const type_info & объект); // для сравнения типов
bool operator != (const type_info & объект); // для сравнения типов
bool before (const type_info & объект); // для внутреннего использования
const char * name (); // возвращает указатель на имя типа

Чтобы сравнивать, нужно брать указатель на имя типа через const char * name ()
typeid наиболее полезен, если задавать указатель полиморфного класса, так как можно будет определить тип объекта. Также и с ссылками.

Часто передаем разыменованный указатель (typeid(*p))
Если p == NULL, то будет сгенерированно исключение типа bad_typeid
Указатель на объект базовый класс может спокойно указывать на объект производного класса !!!

class Base {virtual void f ( ) {...};};
class Derived1: public Base {...};
class Derived2: public Base {...};
int main ( ) {
	int i;
	Base *p, b_ob;
	Derived1 ob1;
	Derived2 ob2;
	cout << "Тип i - " << typeid ( i ) . name ( ) << endl;
	p = & b_ob;
	cout << "p указывает на объект типа " << typeid ( * p ) . name ( ) << endl;
	p = & ob1;
	cout << "p указывает на объект типа " << typeid ( * p ) . name ( ) << endl;
	p = & ob2;
	cout << "p указывает на объект типа " << typeid ( * p ) . name ( ) << endl;
	if ( typeid (ob1) == typeid (ob2) )
		cout << "Тип объектов ob1 и ob2 одинаков\n";
	else
		cout << "Тип объектов ob1 и ob2 не одинаков\n";
	return 0;
}





Станадартные исключения
Текст генерирует компилятор
Все объединены в иерархию, вершина - exception
#include <stdexcept>

class exception {
public:
	exception () throw ();						// конструктор умолчания
	exception (const exception &) throw ();			//копирования
	exception & operator=(const exception &) throw ();	//присваивание
	virtual ~exception () throw ();				//виртуальный деструктор
	virtual const char * what () const throw();
	...
};

bad_alloc
bad_cast, bad_typeid
out_of_rabge - генерируется методом at() контейнеров STL


void f () {
	try { // использование стандартной библиотеки}

	catch (exception & e) {
		cout << "Стандартное исключение" << e.what() << '\n';
	}

	catch (...) {
		cout << "Другое исключение" << '\n';
	}
}



_________________________________________________________________________________________________________________________________________________________________________________________________________________

Лекция 6.1 И 6.2

Шаблоны функций и классов
Параметрический полиморвизм
Ключевое слово template

template < class T >
T sum ( T array[ ], int size ) {
	T res = 0;
	for ( int i = 0; i < size; i++ ) res += array[ i ];
	return res;
}

Правила
1. Смотрим на параметры функции, их количество и типы
2. Далее если подходят несколько, то выбирается более специализированнный (узкий)
3. В случае если подходят и шаблонная, и обычная функции, то выбирается обычная
4. Ошибки нет, если получили ровно 1 подходящую функцию.


Шаблоны классов
template <список_параметров_шаблона> class имя_класса { /*...*/ };
имя_класса < список фактич_парам > объект;

Реализация шаблонного стека
Описание шаблонных методов вне класса

template <class T, int max_size > Шаблонный класс stack.
class stack {
	T s [max_size];
	int top;
public:
	stack ( ) { top = 0;}
	void reset ( ) { top = 0;}
	void push (T i);
	T pop () ;
	bool is_empty ( ) { return top == 0;}
	bool is_full () { return top == max_size;}
};


template <class T, int max_size >			 		template <class T, int max_size >
void stack <T, max_size > :: push (T i) { 			T stack <T, max_size > :: pop ( ) {
	if ( ! is_full () ) { 							if ( ! is_empty () ) {
		s [top] = i; 								top --;
		top ++; 									return s [top];
	} 										}
	else: 									else:
		throw "stack_is_full"; 							throw "stack_is_empty";
} 										}


Сандартная библиотека шаблонов STL
Ядро состоит из: 
1. Контейнеры - хранение данных (таблицы идентификаторов, массив, дерево, список)
2. Итераторы - классы, объекты которых используются для прохождения по контейнеру
3. Алгоритмы - шаблонные функции, которые работают с контейнерами
4. Распределители памяти - класс для расположения контейнера в динамической памяти (так как все контейнеры неограниченного размера)


vector < T > - динамический массив
list < T > - линейный список
stack < T > - стек
queue < T > - очередь
deque < T > - двусторонняя очередь
priority_queue < T > - очередь с приоритетами
set < T > - множество
bitset < N > - множество битов (массив из N бит)
multiset < T > - набор элементов, возможно, одинаковых
map < key, val > - ассоциативный список
multimap < key, val > - ассоциативный список для хранения
пар ключ/значение, где с каждым
ключом может быть связано более
одного значения.

Стандартный набор базовых операций, например:
push_back()
size()


Каждый контейнер в своей public части содержит серию typedef,
где введены стандартные имена типов, например:
value_type - тип элемента,
allocator_type - тип распределителя памяти,
size_type - тип, используемый для индексации,
iterator - итератор,
const_iterator - константный итератор,
reverse_iterator - обратный итератор,
const_reverse_iterator - обратный константный итератор,
pointer - указатель на элемент,
const_pointer - указатель на константный элемент,
reference - ссылка на элемент,
const_reference - ссылка на константный элемент.


#include <memory>
Стандартный распределитель памяти, заданный шаблоном allocator. Он использует new



Класс allocator

template <class T> class allocator {
public:
	typedef T * pointer;
	typedef T & reference;

	allocator ( ) throw ( );

	pointer allocate ( size_type n ); // выделяет память для n объектов типа T
	void deallocate ( pointer p, size_type n ); // освобождает память, отведенную под n объектов типа Т
	void construct ( pointer p, const T & val ); // инициализирует *р значением val
	void destroy ( pointer p ); // вызывает деструктор для *p, память при этом не освобождается
};




Итераторы <iterator>
Класс, объекты которого выполняют такую же роль по
отношению к контейнеру, как указатели по отношению к массиву.
Указатель может использоваться в качестве средства доступа к
элементам массива, а итератор - в качестве средства доступа к
элементам контейнера.
Методы

• iterator begin (); – возвращает итератор, который указывает на первый элемент последовательности.
• const_iterator begin () const; - возвращает константный итератор
• iterator end (); – возвращает итератор, который указывает на элемент, следующий за последним элементом последовательности.
• const_iterator end () const;
• reverse_iterator rbegin (); - возвращает итератор, указывающий на первый элемент в обратной последовательности.
• const_reverse_iterator rbegin () const;
• reverse_iterator rend (); - возвращает итератор, указывающий на элемент, следующий за последним в обратной последовательности.
• const_reverse_iterator rend () const;

Операции:
*p - элемент, на что указывает
p++ - переход к следующему
== - операция сравнения


В библиотеке STL введено 5 категорий итераторов:
• 1. Вывода (output - запись в контейнер) ( *р= , ++)
• 2. Ввода (input - считывание из контейнера) ( = *р, →, ++, ==, !=)
• 3. Однонаправленный (forward) ( *р =, =*р, →, ++ , ==, !=) (1 + 2 -> 3)
• 4. Двунаправленный (bidirectional) ( *р=, =*р, →, ++,--, ==, != ) - list, map, set (можно двигаться в двух направлениях)
• 5. C произвольным доступом (random_access) (*р=, =*р, →, ++,--, ==, !=, [ ], +, -, +=, -=, <, >, <=, >=) - vector,deque

!!!!!!!!!! VECTOR САМЫЙ КРУТОЙ !!!!!!!!!!




<algorithm>
Алгоритм - шаблонная функция, которая работает с контейнерами STL
Ей передаются итераторы, концы фрагмента !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
И могут передаваться другие
Алгоритм не знает, с каким контейнером он работает

Немодифицирующие:
find() - первое вхождение с заданным значением
count()
for_each() - исследуем каждый элемент контейнера с этим значением, но не меняем его

Модифицирующие:
transform() - к каждому
reverse() - переставить
cope() - создать новый контейнер

Сортировка:
sort() - простая
merge() - слияние отсортированных
stable_sort() - сохраняет порядок следования одинаковых элементов (при сортирвке по нескольким ключам)



typename - ключевое слово
Показывает, что параметр шаблона - некий тип
Пишем либо class, либо typename
Путаница - поле данных или тип переменной?
Есои переменная указываем typename

template <class T>
void f (vector <T> & v)
{
	vector <T> :: iterator i = v.begin (); // Err!
	typename vector <T> :: iterator i = v.begin(); // O.K.
}



VECTOR
Конструктор по умолчанию делает все элементы равными нулю
После работы erase, insert, push, pop - итераторы указывают на другие элементы

1. iterator erase (iterator i ); // удаляет элемент, на который указывает данный итератор. Возвращает итератор элемента, следующего за удаленным.

2. iterator erase (iterator st, iterator fin); // удалению подлежат все элементы между st и fin, но fin не удаляется. Возвращает fin.

3. iterator insert ( iterator i , const Т& value = T()); // вставка некоторого значения value перед i. Возвращает итератор вставленного элемента.

4. void insert (iterator i , size_type n, const T& value); // вставка n копий элементов со значением value перед i.

5. void push_back ( const T&value ) ; // добавляет элемент в конец вектора

6. void pop_back () ; // удаляет последний элемент (не возвращает значение!)

7. front (); // возвращает первый элемент

8. back (); // возвращает последний элемент

9. size_type size() const; // выдает количество элементов вектора

10. bool empty () const; // возвращает истину, если вызывающий вектор пуст

11. void clear (); //удаляет все элементы вектора



LIST
1. iterator erase (iterator i ); // удаляет элемент, на который указывает данный итератор. Возвращает итератор элемента, следующего за удаленным.

2. iterator erase (iterator st, iterator fin); // удалению подлежат все элементы между st и fin, но fin не удаляется. Возвращает fin.

3. iterator insert ( iterator i , const Т& value = T()); // вставка некоторого значения value перед i. Возвращает итератор вставленного элемента.

4. void insert (iterator i , size_type n, const T&value); // вставка n копий элементов со значением value перед i.

5. void push_back ( const T&value ) ; // добавляет элемент в конец списка

6. void push_front ( const T&value ) ; // добавляет элемент в начало списка

7. void pop_back ( ) ; // удаляет последний элемент (не возвращает значение!)

8. void pop_front ( ) ; // удаляет первый элемент списка

9. size_type size( ) const; // выдает количество элементов списка

10. bool empty ( ) const; // возвращает истину, если вызывающий список пуст

11. void clear( ); // удаляет все элементы списка


Контейнеры специального вида

Считать строку до \n

#include <iostream> 
#include <string> 
#include <sstream> 
#include <vector> 
using namespace std;

int main () {
	string str, word;
	getline(cin, str);
	vector <string> vecstr;
	istringstream ss (str);

	while (ss >> word)
		vecstr.push_back(word);

	int vsize = vecstr.size();

	for (int i = 0; i < vsize; i++)
		std::cout << vecstr[i] << std::endl;

	return 0; 
}


_________________________________________________________________________________________________________________________________________________________________________________________________________________

Лекция 7.1

rvalue-ссылки
<тип> && <имя> = <временный объект>;
В С++11 можно использовать перегруженные функции для
неконстантных временных объектов, обозначаемых посредством
rvalue-ссылок (имеют особенного адреса).

void f(A & x);	~f(a)		получает параметр по ссылке
void f(A && y);	~f(A())	получает параметр по rvalue-ссылке

A && rr1 =()


final
для классов - они не могут быть базовыми для новых
для виртуальных функций - производные классы не смогут ее заместить


nullptr - константа нулевого указателя
Можно преобрвзовать указатель к любому типу указателю


Лямбда-функции
for_each( v.begin(), v.end(), []( int x ) { std::cout << x << " "; } );

[] - перечисляем локальные переменные (в нашем блоке)
() - формальные параметры
->int (необязательно - тип возвращаемого результата)
{} - тело функции
Если передаем по ссылке, то можем менять

















 

































